; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -S \
; RUN: -passes='cgscc(inline,function(coro-elide,dce),inline,function(coro-elide,dce))' \
; RUN:   | FileCheck %s

declare void @print(i32) nounwind

; resume part of the coroutine
define fastcc void @f.resume(ptr dereferenceable(1)) "ptrauth-calls" {
; CHECK-LABEL: define fastcc void @f.resume(
; CHECK-SAME: ptr dereferenceable(1) [[TMP0:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:    tail call void @print(i32 0)
; CHECK-NEXT:    ret void
;
  tail call void @print(i32 0)
  ret void
}

; destroy part of the coroutine
define fastcc void @f.destroy(ptr) "ptrauth-calls" {
; CHECK-LABEL: define fastcc void @f.destroy(
; CHECK-SAME: ptr [[TMP0:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    tail call void @print(i32 1)
; CHECK-NEXT:    ret void
;
  tail call void @print(i32 1)
  ret void
}

; cleanup part of the coroutine
define fastcc void @f.cleanup(ptr) "ptrauth-calls" {
; CHECK-LABEL: define fastcc void @f.cleanup(
; CHECK-SAME: ptr [[TMP0:%.*]]) #[[ATTR1]] {
; CHECK-NEXT:    tail call void @print(i32 2)
; CHECK-NEXT:    ret void
;
  tail call void @print(i32 2)
  ret void
}

@f.resumers = internal constant [3 x ptr] [ptr @f.resume,
  ptr @f.destroy,
  ptr @f.cleanup]

; a coroutine start function
define ptr @f() "ptrauth-calls" {
; CHECK-LABEL: define ptr @f(
; CHECK-SAME: ) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ID:%.*]] = call token @llvm.coro.id(i32 0, ptr null, ptr @f, ptr @f.resumers)
; CHECK-NEXT:    [[ALLOC:%.*]] = call i1 @llvm.coro.alloc(token [[ID]])
; CHECK-NEXT:    [[HDL:%.*]] = call ptr @llvm.coro.begin(token [[ID]], ptr null)
; CHECK-NEXT:    ret ptr [[HDL]]
;
entry:
  %id = call token @llvm.coro.id(i32 0, ptr null,
  ptr @f,
  ptr @f.resumers)
  %alloc = call i1 @llvm.coro.alloc(token %id)
  %hdl = call ptr @llvm.coro.begin(token %id, ptr null)
  ret ptr %hdl
}

define void @callResume() "ptrauth-calls" {
; CHECK-LABEL: define void @callResume(
; CHECK-SAME: ) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    call void @print(i32 0)
; CHECK-NEXT:    call void @print(i32 2)
; CHECK-NEXT:    ret void
;
entry:
  %hdl = call ptr @f()

  %0 = call ptr @llvm.coro.subfn.addr(ptr %hdl, i8 0)
  %addr0 = getelementptr inbounds { ptr, ptr }, ptr %hdl, i32 0, i32 0
  %addr0_i = ptrtoint ptr %addr0 to i64
  call fastcc void %0(ptr %hdl) [ "ptrauth"(i32 0, i64 %addr0_i) ]

  %1 = call ptr @llvm.coro.subfn.addr(ptr %hdl, i8 1)
  %addr1 = getelementptr inbounds { ptr, ptr }, ptr %hdl, i32 0, i32 1
  %addr1_i = ptrtoint ptr %addr1 to i64
  call fastcc void %1(ptr %hdl) [ "ptrauth"(i32 0, i64 %addr1_i) ]

  ret void
}

; We can't elide a matching ptrauth call/signing-subfn, so emit a sign.
define void @no_call_needs_ptrauth_sign() "ptrauth-calls" {
; CHECK-LABEL: define void @no_call_needs_ptrauth_sign(
; CHECK-SAME: ) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = alloca [1 x i8], align 1
; CHECK-NEXT:    [[VFRAME:%.*]] = bitcast ptr [[TMP0]] to ptr
; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds { ptr, ptr }, ptr [[VFRAME]], i32 0, i32 0
; CHECK-NEXT:    [[TMP2:%.*]] = ptrtoint ptr [[TMP1]] to i64
; CHECK-NEXT:    [[TMP8:%.*]] = call i64 @llvm.ptrauth.blend(i64 [[TMP2]], i64 22017)
; CHECK-NEXT:    [[TMP3:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.resume to i64), i32 0, i64 [[TMP8]])
; CHECK-NEXT:    [[ADDR0:%.*]] = getelementptr inbounds { ptr, ptr }, ptr [[VFRAME]], i32 0, i32 0
; CHECK-NEXT:    [[ADDR0_I:%.*]] = ptrtoint ptr [[ADDR0]] to i64
; CHECK-NEXT:    [[F0_P:%.*]] = inttoptr i64 [[TMP3]] to ptr
; CHECK-NEXT:    call fastcc void [[F0_P]](ptr [[VFRAME]]) [ "ptrauth"(i32 0, i64 [[ADDR0_I]]) ]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds { ptr, ptr }, ptr [[VFRAME]], i32 0, i32 1
; CHECK-NEXT:    [[TMP5:%.*]] = ptrtoint ptr [[TMP4]] to i64
; CHECK-NEXT:    [[TMP7:%.*]] = call i64 @llvm.ptrauth.blend(i64 [[TMP5]], i64 15351)
; CHECK-NEXT:    [[TMP6:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.cleanup to i64), i32 0, i64 [[TMP7]])
; CHECK-NEXT:    [[ADDR1:%.*]] = getelementptr inbounds { ptr, ptr }, ptr [[VFRAME]], i32 0, i32 1
; CHECK-NEXT:    [[ADDR1_I:%.*]] = ptrtoint ptr [[ADDR1]] to i64
; CHECK-NEXT:    [[F1_P:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    call fastcc void [[F1_P]](ptr [[VFRAME]]) [ "ptrauth"(i32 0, i64 [[ADDR1_I]]) ]
; CHECK-NEXT:    ret void
;
entry:
  %hdl = call ptr @f()

  %f0 = call ptr @llvm.coro.subfn.addr(ptr %hdl, i8 0)
  %addr0 = getelementptr inbounds { ptr, ptr }, ptr %hdl, i32 0, i32 0
  %addr0_i = ptrtoint ptr %addr0 to i64
  %f0_i = ptrtoint ptr %f0 to i64
  %f0_p = inttoptr i64 %f0_i to ptr
  call fastcc void %f0_p(ptr %hdl) [ "ptrauth"(i32 0, i64 %addr0_i) ]

  %f1 = call ptr @llvm.coro.subfn.addr(ptr %hdl, i8 1)
  %addr1 = getelementptr inbounds { ptr, ptr }, ptr %hdl, i32 0, i32 1
  %addr1_i = ptrtoint ptr %addr1 to i64
  %f1_i = ptrtoint ptr %f1 to i64
  %f1_p = inttoptr i64 %f1_i to ptr
  call fastcc void %f1_p(ptr %hdl) [ "ptrauth"(i32 0, i64 %addr1_i) ]

  ret void
}

; no devirtualization here, since coro.begin info parameter is null
define void @no_devirt_info_null() "ptrauth-calls" {
; CHECK-LABEL: define void @no_devirt_info_null(
; CHECK-SAME: ) #[[ATTR1]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[ID:%.*]] = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
; CHECK-NEXT:    [[HDL:%.*]] = call ptr @llvm.coro.begin(token [[ID]], ptr null)
; CHECK-NEXT:    [[TMP0:%.*]] = call ptr @llvm.coro.subfn.addr(ptr [[HDL]], i8 0)
; CHECK-NEXT:    call fastcc void [[TMP0]](ptr [[HDL]])
; CHECK-NEXT:    [[TMP1:%.*]] = call ptr @llvm.coro.subfn.addr(ptr [[HDL]], i8 1)
; CHECK-NEXT:    call fastcc void [[TMP1]](ptr [[HDL]])
; CHECK-NEXT:    ret void
;
entry:
  %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
  %hdl = call ptr @llvm.coro.begin(token %id, ptr null)

  %0 = call ptr @llvm.coro.subfn.addr(ptr %hdl, i8 0)
  call fastcc void %0(ptr %hdl)

  %1 = call ptr @llvm.coro.subfn.addr(ptr %hdl, i8 1)
  call fastcc void %1(ptr %hdl)

  ret void
}
