; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --check-globals all --include-generated-funcs --version 5
; RUN: opt < %s -passes='cgscc(coro-split),simplifycfg,early-cse' -S | FileCheck %s

define ptr @f() presplitcoroutine "ptrauth-calls" {
entry:
  %id = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr null)
  %need.alloc = call i1 @llvm.coro.alloc(token %id)
  br i1 %need.alloc, label %dyn.alloc, label %begin

dyn.alloc:
  %size = call i32 @llvm.coro.size.i32()
  %alloc = call ptr @malloc(i32 %size)
  br label %begin

begin:
  %phi = phi ptr [ null, %entry ], [ %alloc, %dyn.alloc ]
  %hdl = call ptr @llvm.coro.begin(token %id, ptr %phi)
  call void @print(i32 0)
  %0 = call i8 @llvm.coro.suspend(token none, i1 false)
  switch i8 %0, label %suspend [i8 0, label %resume
  i8 1, label %cleanup]
resume:
  call void @print(i32 1)
  br label %cleanup

cleanup:
  %mem = call ptr @llvm.coro.free(token %id, ptr %hdl)
  call void @free(ptr %mem)
  br label %suspend
suspend:
  call i1 @llvm.coro.end(ptr %hdl, i1 0, token none)
  ret ptr %hdl
}

; Make a safe_elide call to f and CoroSplit should generate the .noalloc variant
define void @caller() presplitcoroutine "ptrauth-calls" {
entry:
  %ptr = call ptr @f() #1
  ret void
}






declare ptr @llvm.coro.free(token, ptr)
declare i32 @llvm.coro.size.i32()
declare i8  @llvm.coro.suspend(token, i1)
declare void @llvm.coro.resume(ptr)
declare void @llvm.coro.destroy(ptr)

declare token @llvm.coro.id(i32, ptr, ptr, ptr)
declare i1 @llvm.coro.alloc(token)
declare ptr @llvm.coro.begin(token, ptr)
declare i1 @llvm.coro.end(ptr, i1, token)

declare noalias ptr @malloc(i32) allockind("alloc,uninitialized") "alloc-family"="malloc"
declare void @print(i32)
declare void @free(ptr) willreturn allockind("free") "alloc-family"="malloc"

!0 = !{i32 846595819, ptr null}
attributes #1 = { coro_elide_safe }
;.
; CHECK: @f.resumers = private constant [3 x ptr] [ptr @f.resume, ptr @f.destroy, ptr @f.cleanup]
; CHECK: @f.resumers.1 = private constant [4 x ptr] [ptr @f.resume, ptr @f.destroy, ptr @f.cleanup, ptr @f.noalloc]
;.
; CHECK-LABEL: define ptr @f(
; CHECK-SAME: ) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[ID:%.*]] = call token @llvm.coro.id(i32 0, ptr null, ptr null, ptr @f.resumers.1)
; CHECK-NEXT:    [[NEED_ALLOC:%.*]] = call i1 @llvm.coro.alloc(token [[ID]])
; CHECK-NEXT:    br i1 [[NEED_ALLOC]], label %[[DYN_ALLOC:.*]], label %[[BEGIN:.*]]
; CHECK:       [[DYN_ALLOC]]:
; CHECK-NEXT:    [[ALLOC:%.*]] = call ptr @malloc(i32 24)
; CHECK-NEXT:    br label %[[BEGIN]]
; CHECK:       [[BEGIN]]:
; CHECK-NEXT:    [[PHI:%.*]] = phi ptr [ [[ALLOC]], %[[DYN_ALLOC]] ], [ null, %[[ENTRY]] ]
; CHECK-NEXT:    [[HDL:%.*]] = call noalias nonnull ptr @llvm.coro.begin(token [[ID]], ptr [[PHI]])
; CHECK-NEXT:    [[TMP8:%.*]] = ptrtoint ptr [[HDL]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = call i64 @llvm.ptrauth.blend(i64 [[TMP8]], i64 22017)
; CHECK-NEXT:    [[TMP1:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.resume to i64), i32 0, i64 [[TMP9]])
; CHECK-NEXT:    [[TMP2:%.*]] = inttoptr i64 [[TMP1]] to ptr
; CHECK-NEXT:    store ptr [[TMP2]], ptr [[HDL]], align 8
; CHECK-NEXT:    [[DESTROY_ADDR:%.*]] = getelementptr inbounds nuw [[F_FRAME:%.*]], ptr [[HDL]], i32 0, i32 1
; CHECK-NEXT:    [[TMP3:%.*]] = ptrtoint ptr [[DESTROY_ADDR]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = call i64 @llvm.ptrauth.blend(i64 [[TMP3]], i64 15351)
; CHECK-NEXT:    [[TMP4:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.destroy to i64), i32 0, i64 [[TMP10]])
; CHECK-NEXT:    [[TMP5:%.*]] = inttoptr i64 [[TMP4]] to ptr
; CHECK-NEXT:    [[TMP6:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.cleanup to i64), i32 0, i64 [[TMP10]])
; CHECK-NEXT:    [[TMP7:%.*]] = inttoptr i64 [[TMP6]] to ptr
; CHECK-NEXT:    [[TMP0:%.*]] = select i1 [[NEED_ALLOC]], ptr [[TMP5]], ptr [[TMP7]]
; CHECK-NEXT:    store ptr [[TMP0]], ptr [[DESTROY_ADDR]], align 8
; CHECK-NEXT:    call void @print(i32 0)
; CHECK-NEXT:    [[INDEX_ADDR1:%.*]] = getelementptr inbounds nuw [[F_FRAME]], ptr [[HDL]], i32 0, i32 2
; CHECK-NEXT:    store i1 false, ptr [[INDEX_ADDR1]], align 1
; CHECK-NEXT:    ret ptr [[HDL]]
;
;
; CHECK-LABEL: define void @caller(
; CHECK-SAME: ) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[PTR:%.*]] = call ptr @f() #[[ATTR10:[0-9]+]]
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define internal fastcc void @f.resume(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(24) [[HDL:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY_RESUME:.*:]]
; CHECK-NEXT:    call void @print(i32 1)
; CHECK-NEXT:    call void @free(ptr [[HDL]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define internal fastcc void @f.destroy(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(24) [[HDL:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY_DESTROY:.*:]]
; CHECK-NEXT:    call void @free(ptr [[HDL]])
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define internal fastcc void @f.cleanup(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(24) [[HDL:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY_CLEANUP:.*:]]
; CHECK-NEXT:    ret void
;
;
; CHECK-LABEL: define internal ptr @f.noalloc(
; CHECK-SAME: ptr noundef nonnull align 8 dereferenceable(24) [[TMP0:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP1:%.*]] = ptrtoint ptr [[TMP0]] to i64
; CHECK-NEXT:    [[TMP9:%.*]] = call i64 @llvm.ptrauth.blend(i64 [[TMP1]], i64 22017)
; CHECK-NEXT:    [[TMP2:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.resume to i64), i32 0, i64 [[TMP9]])
; CHECK-NEXT:    [[TMP3:%.*]] = inttoptr i64 [[TMP2]] to ptr
; CHECK-NEXT:    store ptr [[TMP3]], ptr [[TMP0]], align 8
; CHECK-NEXT:    [[DESTROY_ADDR:%.*]] = getelementptr inbounds nuw [[F_FRAME:%.*]], ptr [[TMP0]], i32 0, i32 1
; CHECK-NEXT:    [[TMP4:%.*]] = ptrtoint ptr [[DESTROY_ADDR]] to i64
; CHECK-NEXT:    [[TMP10:%.*]] = call i64 @llvm.ptrauth.blend(i64 [[TMP4]], i64 15351)
; CHECK-NEXT:    [[TMP5:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.destroy to i64), i32 0, i64 [[TMP10]])
; CHECK-NEXT:    [[TMP6:%.*]] = inttoptr i64 [[TMP5]] to ptr
; CHECK-NEXT:    [[TMP7:%.*]] = call i64 @llvm.ptrauth.sign(i64 ptrtoint (ptr @f.cleanup to i64), i32 0, i64 [[TMP10]])
; CHECK-NEXT:    [[TMP8:%.*]] = inttoptr i64 [[TMP7]] to ptr
; CHECK-NEXT:    store ptr [[TMP8]], ptr [[DESTROY_ADDR]], align 8
; CHECK-NEXT:    call void @print(i32 0)
; CHECK-NEXT:    [[INDEX_ADDR1:%.*]] = getelementptr inbounds nuw [[F_FRAME]], ptr [[TMP0]], i32 0, i32 2
; CHECK-NEXT:    store i1 false, ptr [[INDEX_ADDR1]], align 1
; CHECK-NEXT:    ret ptr [[TMP0]]
;
;.
; CHECK: attributes #[[ATTR0]] = { "ptrauth-calls" }
; CHECK: attributes #[[ATTR1]] = { presplitcoroutine "ptrauth-calls" }
; CHECK: attributes #[[ATTR2:[0-9]+]] = { nounwind memory(argmem: read) }
; CHECK: attributes #[[ATTR3:[0-9]+]] = { nounwind memory(none) }
; CHECK: attributes #[[ATTR4:[0-9]+]] = { nounwind }
; CHECK: attributes #[[ATTR5:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(argmem: read) }
; CHECK: attributes #[[ATTR6:[0-9]+]] = { allockind("alloc,uninitialized") "alloc-family"="malloc" }
; CHECK: attributes #[[ATTR7:[0-9]+]] = { willreturn allockind("free") "alloc-family"="malloc" }
; CHECK: attributes #[[ATTR8:[0-9]+]] = { nomerge nounwind }
; CHECK: attributes #[[ATTR9:[0-9]+]] = { nocallback nofree nosync nounwind willreturn memory(none) }
; CHECK: attributes #[[ATTR10]] = { coro_elide_safe }
;.
